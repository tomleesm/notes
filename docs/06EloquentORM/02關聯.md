# 關聯

## 簡介

資料庫表通常相互關聯。例如，一篇部落格文章可能有許多評論，或者一個訂單對應一個下單使用者。`Eloquent` 讓這些關聯的管理和使用變得簡單，並支援多種常用的關聯類型：

## 定義關聯

Eloquent 關聯在 Eloquent 模型類中以方法的形式呈現。如同 Eloquent 模型本身，關聯也可以作為強大的[查詢語句構造器](/docs/laravel/10.x/queries)，使用，提供了強大的鏈式呼叫和查詢功能。例如，我們可以在 `posts` 關聯的鏈式呼叫中附加一個約束條件：

    $user->posts()->where('active', 1)->get();

不過在深入使用關聯之前，讓我們先學習如何定義每種關聯類型。

### 一對一

一對一是最基本的資料庫關係。 例如，一個 `User` 模型可能與一個 `Phone` 模型相關聯。為了定義這個關聯關係，我們要在 `User` 模型中寫一個 `phone` 方法。 在 `phone` 方法中呼叫 `hasOne` 方法並返回其結果。  `hasOne` 方法被定義在 `Illuminate\Database\Eloquent\Model` 這個模型基類中：

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\HasOne;

    class User extends Model
    {
        /**
         * 獲取與使用者相關的電話記錄
         */
        public function phone(): HasOne
        {
            return $this->hasOne(Phone::class);
        }
    }

`hasOne` 方法的第一個參數是關聯模型的類名。一旦定義了模型關聯，我們就可以使用 Eloquent 的動態屬性獲得相關的記錄。動態屬性允許你訪問該關聯方法，就像訪問模型中定義的屬性一樣：

    $phone = User::find(1)->phone;

Eloquent 基於父模型 `User` 的名稱來確定關聯模型 `Phone` 的外部索引鍵名稱。在本例中，會自動假定 `Phone` 模型有一個 `user_id` 的外部索引鍵。如果你想重寫這個約定，可以傳遞第二個參數給 `hasOne` 方法：

    return $this->hasOne(Phone::class, 'foreign_key');



另外，Eloquent 假設外部索引鍵的值是與父模型的主鍵（Primary Key）相同的。換句話說，Eloquent 將會通過 `Phone` 記錄的 `user_id` 列中尋找與使用者表的 `id` 列相匹配的值。如果你希望使用自訂的主鍵值，而不是使用 `id` 或者模型中的 `$primaryKey` 屬性，你可以給 `hasOne` 方法傳遞第三個參數：

    return $this->hasOne(Phone::class, 'foreign_key', 'local_key');

#### 定義反向關聯

我們已經能從 `User` 模型訪問到 `Phone` 模型了。接下來，讓我們再在 `Phone` 模型上定義一個關聯，它能讓我們訪問到擁有該電話的使用者。我們可以使用 `belongsTo` 方法來定義反向關聯， `belongsTo` 方法與 `hasOne` 方法相對應：

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\BelongsTo;

    class Phone extends Model
    {
        /**
         * 獲取擁有此電話的使用者
         */
        public function user(): BelongsTo
        {
            return $this->belongsTo(User::class);
        }
    }

在呼叫 `user` 方法時，Eloquent 會嘗試尋找一個 `User` 模型，該 `User` 模型上的 `id` 欄位會與 `Phone` 模型上的 `user_id` 欄位相匹配。

Eloquent 通過關聯方法（`user`）的名稱並使用 `_id` 作為後綴名來確定外部索引鍵名稱。因此，在本例中，Eloquent 會假設 `Phone` 模型有一個 `user_id` 欄位。但是，如果 `Phone` 模型的外部索引鍵不是 `user_id`，這時你可以給 `belongsTo` 方法的第二個參數傳遞一個自訂鍵名：

    /**
     * 獲取擁有此電話的使用者
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class, 'foreign_key');
    }



如果父模型的主鍵未使用 `id` 作為欄位名，或者你想要使用其他的欄位來匹配相關聯的模型，那麼你可以向 `belongsTo` 方法傳遞第三個參數，這個參數是在父模型中自己定義的欄位名稱：

    /**
     * 獲取當前手機號的使用者
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class, 'foreign_key', 'owner_key');
    }

### 一對多

當要定義一個模型是其他 （一個或者多個）模型的父模型這種關係時，可以使用一對多關聯。例如，一篇部落格可以有很多條評論。和其他模型關聯一樣，一對多關聯也是在 Eloquent 模型檔案中用一個方法來定義的：

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\HasMany;

    class Post extends Model
    {
        /**
         * 獲取這篇部落格的所有評論
         */
        public function comments(): HasMany
        {
            return $this->hasMany(Comment::class);
        }
    }

注意，Eloquent 將會自動為 `Comment` 模型選擇一個合適的外部索引鍵。通常，這個外部索引鍵是通過使用父模型的「蛇形命名」方式，然後再加上 `_id`. 的方式來命名的。因此，在上面這個例子中，Eloquent 將會默認 `Comment` 模型的外部索引鍵是 `post_id` 欄位。

如果關聯方法被定義，那麼我們就可以通過 `comments` 屬性來訪問相關的評論 [集合](/docs/laravel/10.x/eloquent-collections)。注意，由於 Eloquent 提供了「動態屬性」，所以我們就可以像訪問模型屬性一樣來訪問關聯方法：

    use App\Models\Post;

    $comments = Post::find(1)->comments;

    foreach ($comments as $comment) {
        // ...
    }



由於所有的關係都可以看成是查詢構造器，所以你也可以通過鏈式呼叫的方式，在 `comments` 方法中繼續新增條件約束：

    $comment = Post::find(1)->comments()
                        ->where('title', 'foo')
                        ->first();

像 `hasOne` 方法一樣，你也可以通過將附加參數傳遞給 `hasMany` 方法來覆蓋外部索引鍵和本地鍵：

    return $this->hasMany(Comment::class, 'foreign_key');

    return $this->hasMany(Comment::class, 'foreign_key', 'local_key');

### 一對多 (反向) / 屬於

目前我們可以訪問一篇文章的所有評論，下面我們可以定義一個關聯關係，從而讓我們可以通過一條評論來獲取到它所屬的文章。這個關聯關係是 `hasMany` 的反向，可以在子模型中通過 `belongsTo` 方法來定義這種關聯關係：

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\BelongsTo;

    class Comment extends Model
    {
        /**
         * 獲取這條評論所屬的文章。
         */
        public function post(): BelongsTo
        {
            return $this->belongsTo(Post::class);
        }
    }

如果定義了這種關聯關係，那麼我們就可以通過 `Comment` 模型中的 `post` 「動態屬性」來獲取到這條評論所屬的文章：

    use App\Models\Comment;

    $comment = Comment::find(1);

    return $comment->post->title;

在上面這個例子中，Eloquent 將會嘗試尋找 `Post` 模型中的 `id` 欄位與 `Comment` 模型中的 `post_id` 欄位相匹配。

Eloquent 通過檢查關聯方法的名稱，從而在關聯方法名稱後面加上 `_` ，然後再加上父模型 （Post）的主鍵名稱，以此來作為默認的外部索引鍵名。因此，在上面這個例子中，Eloquent 將會默認 `Post` 模型在 `comments` 表中的外部索引鍵是 `post_id`。


但是，如果你的外部索引鍵不遵循這種約定的話，那麼你可以傳遞一個自訂的外部索引鍵名來作為 `belongsTo` 方法的第二個參數：

    /**
     * 獲取這條評論所屬的文章。
     */
    public function post(): BelongsTo
    {
        return $this->belongsTo(Post::class, 'foreign_key');
    }

如果你的父表不使用 `id` 作為主鍵，或者你希望使用不同的列來關聯模型，你可以將第三個參數傳遞給 `belongsTo` 方法，指定父表的自訂鍵：

    /**
     * 獲取這條評論所屬的文章。
     */
    public function post(): BelongsTo
    {
        return $this->belongsTo(Post::class, 'foreign_key', 'owner_key');
    }

#### 默認模型

當 `belongsTo`，`hasOne`，`hasOneThrough` 和 `morphOne` 這些關聯方法返回 `null` 的時候，你可以定義一個默認的模型返回。該模式通常被稱為 [空對象模式](https://en.wikipedia.org/wiki/Null_Object_pattern)，它可以幫你省略程式碼中的一些條件判斷。在下面這個例子中，如果 `Post` 模型中沒有使用者，那麼 `user` 關聯關係將會返回一個空的 `App\Models\User` 模型：

    /**
     * 獲取文章的作者。
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class)->withDefault();
    }

可以向 `withDefault` 方法傳遞陣列或者閉包來填充默認模型的屬性。

    /**
     * 獲取文章的作者。
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class)->withDefault([
            'name' => 'Guest Author',
        ]);
    }

    /**
     * 獲取文章的作者。
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class)->withDefault(function (User $user, Post $post) {
            $user->name = 'Guest Author';
        });
    }



#### 查詢所屬關係

在查詢「所屬」的子模型時，可以建構 `where` 語句來檢索相應的 Eloquent 模型：

    use App\Models\Post;

    $posts = Post::where('user_id', $user->id)->get();

但是，你會發現使用 `whereBelongsTo` 方法更方便，它會自動確定給定模型的正確關係和外部索引鍵：

    $posts = Post::whereBelongsTo($user)->get();

你還可以向 `whereBelongsTo` 方法提供一個 [集合](/docs/laravel/10.x/eloquent-collections) 實例。 這樣 Laravel 將檢索屬於集合中任何父模型的子模型：

    $users = User::where('vip', true)->get();

    $posts = Post::whereBelongsTo($users)->get();

默認情況下，Laravel 將根據模型的類名來確定給定模型的關聯關係； 你也可以通過將關係名稱作為 `whereBelongsTo` 方法的第二個參數來手動指定關係名稱：

    $posts = Post::whereBelongsTo($user, 'author')->get();

### 一對多檢索

有時一個模型可能有許多相關模型，如果你想很輕鬆的檢索「最新」或「最舊」的相關模型。例如，一個 `User` 模型可能與許多 `Order` 模型相關，但你想定義一種方便的方式來與使用者最近下的訂單進行互動。 可以使用 `hasOne` 關係類型結合 `ofMany` 方法來完成此操作：

```php
/**
 * 獲取使用者最新的訂單。
 */
public function latestOrder(): HasOne
{
    return $this->hasOne(Order::class)->latestOfMany();
}
```



同樣，你可以定義一個方法來檢索 「oldest」或第一個相關模型：

```php
/**
 * 獲取使用者最早的訂單。
 */
public function oldestOrder(): HasOne
{
    return $this->hasOne(Order::class)->oldestOfMany();
}
```

默認情況下，`latestOfMany` 和 `oldestOfMany` 方法將根據模型的主鍵檢索最新或最舊的相關模型，該主鍵必須是可排序的。 但是，有時你可能希望使用不同的排序條件從更大的關係中檢索單個模型。

例如，使用 `ofMany` 方法，可以檢索使用者最昂貴的訂單。 `ofMany` 方法接受可排序列作為其第一個參數，以及在查詢相關模型時應用哪個聚合函數（`min` 或 `max`）：

```php
/**
 * 獲取使用者最昂貴的訂單。
 */
public function largestOrder(): HasOne
{
    return $this->hasOne(Order::class)->ofMany('price', 'max');
}
```

> **注意**
> 因為 PostgreSQL 不支援對 UUID 列執行 `MAX` 函數，所以目前無法將一對多關係與 PostgreSQL UUID 列結合使用。

#### 進階一對多檢索

可以建構更高級的「一對多檢索」關係。例如，一個 `Product` 模型可能有許多關聯的 `Price` 模型，即使在新定價發佈後，這些模型也會保留在系統中。此外，產品的新定價資料能夠通過 `published_at` 列提前發佈，以便在未來某日生效。

因此，我們需要檢索最新的發佈定價。 此外，如果兩個價格的發佈日期相同，我們優先選擇 ID 更大的價格。 為此，我們必須將一個陣列傳遞給 `ofMany` 方法，其中包含確定最新價格的可排序列。此外，將提供一個閉包作為 `ofMany` 方法的第二個參數。此閉包將負責向關係查詢新增額外的發佈日期約束：

```php
/**
 * 獲取產品的當前定價。
 */
public function currentPricing(): HasOne
{
    return $this->hasOne(Price::class)->ofMany([
        'published_at' => 'max',
        'id' => 'max',
    ], function (Builder $query) {
        $query->where('published_at', '<', now());
    });
}
```



### 遠端一對一

「遠端一對一」關聯定義了與另一個模型的一對一的關聯。然而，這種關聯是聲明的模型通過第三個模型來與另一個模型的一個實例相匹配。

例如，在一個汽車維修的應用程式中，每一個 `Mechanic` 模型都與一個 `Car` 模型相關聯，同時每一個 `Car` 模型也和一個 `Owner` 模型相關聯。雖然維修師（mechanic）和車主（owner）在資料庫中並沒有直接的關聯，但是維修師可以通過 `Car` 模型來找到車主。讓我們來看看定義這種關聯所需要的資料表：

    mechanics
        id - integer
        name - string

    cars
        id - integer
        model - string
        mechanic_id - integer

    owners
        id - integer
        name - string
        car_id - integer

既然我們已經瞭解了遠端一對一的表結構，那麼我們就可以在 `Mechanic` 模型中定義這種關聯：

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\HasOneThrough;

    class Mechanic extends Model
    {
        /**
         * 獲取汽車的主人。
         */
        public function carOwner(): HasOneThrough
        {
            return $this->hasOneThrough(Owner::class, Car::class);
        }
    }

傳遞給 `hasOneThrough` 方法的第一個參數是我們希望訪問的最終模型的名稱，而第二個參數是中間模型的名稱。

或者，如果相關的關聯已經在關聯中涉及的所有模型上被定義，你可以通過呼叫 `through` 方法和提供這些關聯的名稱來流式定義一個「遠端一對一」關聯。例如，`Mechanic` 模型有一個 `cars` 關聯，`Car` 模型有一個 `owner` 關聯，你可以這樣定義一個連接維修師和車主的「遠端一對一」關聯：

```php
// 基於字串的語法...
return $this->through('cars')->has('owner');

// 動態語法...
return $this->throughCars()->hasOwner();
```

#### 鍵名約定

當使用遠端一對一進行關聯查詢時，Eloquent 將會使用約定的外部索引鍵名。如果你想要自訂相關聯的鍵名的話，可以傳遞兩個參數來作為「hasOneThrough」 方法的第三個和第四個參數。第三個參數是中間表的外部索引鍵名。第四個參數是最終想要訪問的模型的外部索引鍵名。第五個參數是當前模型的本地鍵名，第六個參數是中間模型的本地鍵名：

    class Mechanic extends Model
    {
        /**
         * Get the car's owner.
         */
        public function carOwner(): HasOneThrough
        {
            return $this->hasOneThrough(
                Owner::class,
                Car::class,
                'mechanic_id', // 機械師表的外部索引鍵...
                'car_id', // 車主表的外部索引鍵...
                'id', // 機械師表的本地鍵...
                'id' // 汽車表的本地鍵...
            );
        }
    }

如果所涉及的模型已經定義了相關關係，可以呼叫 `through` 方法並提供關係名來定義「遠端一對一」關聯。該方法的優點是重複使用已有關係上定義的主鍵約定：
```php
// 基本語法...
return $this->through('cars')->has('owner');

// 動態語法...
return $this->throughCars()->hasOwner();
```

### 遠端一對多

「遠端一對多」關聯是可以通過中間關係來實現遠端一對多的。例如，我們正在建構一個像 [Laravel Vapor](https://vapor.laravel.com)這樣的部署平台。一個 `Project` 模型可以通過一個中間的 `Environment` 模型來訪問許多個 `Deployment` 模型。就像上面的這個例子，可以在給定的 environment 中很方便的獲取所有的 deployments。下面是定義這種關聯關係所需要的資料表：

    projects
        id - integer
        name - string

    environments
        id - integer
        project_id - integer
        name - string

    deployments
        id - integer
        environment_id - integer
        commit_hash - string


既然我們已經檢查了關係的表結構，現在讓我們在 `Project` 模型上定義該關係：

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\HasManyThrough;

    class Project extends Model
    {
        /**
         * 獲取該項目的所有部署。
         */
        public function deployments(): HasManyThrough
        {
            return $this->hasManyThrough(Deployment::class, Environment::class);
        }
    }

`hasManyThrough` 方法中傳遞的第一個參數是我們希望訪問的最終模型名稱，而第二個參數是中間模型的名稱。

或者，所有模型上都定義好了關係，你可以通過呼叫 `through` 方法並提供這些關係的名稱來定義「has-many-through」關係。例如，如果  `Project` 模型具有 `environments` 關係，而 `Environment` 模型具有 `deployments` 關係，則可以定義連接 project 和 deployments 的「has-many-through」關係，如下所示：

```php
// 基於字串的語法。。。
return $this->through('environments')->has('deployments');

// 動態語法。。。
return $this->throughEnvironments()->hasDeployments();
```
雖然 `Deployment` 模型的表格不包含 `project_id` 列，但 `hasManyThrough` 關係通過 `$project->deployments` 提供了訪問項目的部署方式。為了檢索這些模型，Eloquent 在中間的 `Environment` 模型表中檢查 `project_id` 列。在找到相關的 environment ID 後，它們被用來查詢 `Deployment` 模型。

#### 鍵名約定

在執行關係查詢時，通常會使用典型的 Eloquent 外部索引鍵約定。如果你想要自訂關係鍵名，可以將它們作為 `hasManyThrough` 方法的第三個和第四個參數傳遞。第三個參數是中間模型上的外部索引鍵名稱。第四個參數是最終模型上的外部索引鍵名稱。第五個參數是本地鍵，而第六個參數是中間模型的本地鍵：

    class Project extends Model
    {
        public function deployments(): HasManyThrough
        {
            return $this->hasManyThrough(
                Deployment::class,
                Environment::class,
                'project_id', // 在 environments 表上的外部索引鍵...
                'environment_id', // 在 deployments 表上的外部索引鍵...
                'id', // 在 projects 表上的本地鍵...
                'id' // 在 environments 表格上的本地鍵...
            );
        }
    }



或者，如前所述，如果涉及關係的相關關係已經在所有模型上定義，你可以通過呼叫 `through` 方法並提供這些關係的名稱來定義「has-many-through」關係。這種方法的優點是可以重複使用已經定義在現有關係上的鍵約定：

```php
// 基於字串的語法。。。
return $this->through('environments')->has('deployments');

// 動態語法。。。
return $this->throughEnvironments()->hasDeployments();
```

## 多對多關聯

多對多關聯比 `hasOne` 和 `hasMany` 關聯略微複雜。舉個例子，一個使用者可以擁有多個角色，同時這些角色也可以分配給其他使用者。例如，一個使用者可是「作者」和「編輯」；當然，這些角色也可以分配給其他使用者。所以，一個使用者可以擁有多個角色，一個角色可以分配給多個使用者。

#### 表結構

要定義這種關聯，需要三個資料庫表: `users`, `roles` 和 `role_user`。`role_user` 表的命名是由關聯的兩個模型按照字母順序來的，並且包含了 `user_id` 和 `role_id` 欄位。該表用作連結 `users` 和 `roles` 的中間表

特別提醒，由於角色可以屬於多個使用者，因此我們不能簡單地在 `roles` 表上放置 `user_id` 列。如果這樣，這意味著角色只能屬於一個使用者。為了支援將角色分配給多個使用者，需要使用 `role_user` 表。我們可以這樣定義表結構：

    users
        id - integer
        name - string

    roles
        id - integer
        name - string

    role_user
        user_id - integer
        role_id - integer



#### 模型結構

多對多關聯是通過呼叫 `belongsToMany` 方法結果的方法來定義的。 `belongsToMany` 方法由 `Illuminate\Database\Eloquent\Model` 基類提供，所有應用程式的 Eloquent 模型都使用該基類。 例如，讓我們在 `User` 模型上定義一個 `roles` 方法。 傳遞給此方法的第一個參數是相關模型類的名稱：

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\BelongsToMany;

    class User extends Model
    {
        /**
         * 使用者所擁有的角色
         */
        public function roles(): BelongsToMany
        {
            return $this->belongsToMany(Role::class);
        }
    }

定義關係後，可以使用 `roles` 動態關係屬性訪問使用者的角色：

    use App\Models\User;

    $user = User::find(1);

    foreach ($user->roles as $role) {
        // ...
    }

由於所有的關係也可以作為查詢建構器，你可以通過呼叫 `roles()` 方法查詢來為關係新增約束：

    $roles = User::find(1)->roles()->orderBy('name')->get();

為了確定關係的中間表的表名，Eloquent 會按字母順序連接兩個相關的模型名。 你也可以隨意覆蓋此約定。 通過將第二個參數傳遞給 `belongsToMany` 方法來做到這一點：

    return $this->belongsToMany(Role::class, 'role_user');

除了自訂連接表的表名，你還可以通過傳遞額外的參數到 `belongsToMany` 方法來定義該表中欄位的鍵名。第三個參數是定義此關聯的模型在連接表裡的外部索引鍵名，第四個參數是另一個模型在連接表裡的外部索引鍵名:

    return $this->belongsToMany(Role::class, 'role_user', 'user_id', 'role_id');



#### 定義反向關聯

要定義多對多的反向關聯，只需要在關聯模型中呼叫 `belongsToMany` 方法。我們在 `Role` 模型中定義 `users` 方法:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\BelongsToMany;

    class Role extends Model
    {
        /**
         * 擁有此角色的使用者
         */
        public function users(): BelongsToMany
        {
            return $this->belongsToMany(User::class);
        }
    }

如你所見，除了引用 `App\Models\User` 模型之外，該關係的定義與其對應的 `User` 模型完全相同。 由於我們復用了 `belongsToMany` 方法，所以在定義多對多關係的「反向」關係時，所有常用的表和鍵自訂選項都可用。

### 獲取中間表欄位

如上所述，處理多對多關係需要一個中間表。 Eloquent 提供了一些非常有用的方式來與它進行互動。 假設我們的 `User` 對象關聯了多個 `Role` 對象。在獲得這些關聯對象後，可以使用模型的 `pivot` 屬性訪問中間表的屬性：

    use App\Models\User;

    $user = User::find(1);

    foreach ($user->roles as $role) {
        echo $role->pivot->created_at;
    }

需要注意的是，我們獲取的每個 `Role` 模型對象，都會被自動賦予 `pivot` 屬性，它代表中間表的一個模型對象，並且可以像其他的 Eloquent 模型一樣使用。

默認情況下，`pivot` 對象只包含兩個關聯模型的主鍵，如果你的中間表裡還有其他額外欄位，你必須在定義關聯時明確指出：

    return $this->belongsToMany(Role::class)->withPivot('active', 'created_by');



如果你想讓中間表自動維護 `created_at` 和 `updated_at` 時間戳，那麼在定義關聯時附加上 `withTimestamps` 方法即可：

    return $this->belongsToMany(Role::class)->withTimestamps();

> **注意**
> 使用 Eloquent 自動維護時間戳的中間表需要同時具有 `created_at` 和 `updated_at`時間戳欄位。

#### 自訂 pivot 屬性名稱

如前所述，可以通過 `pivot` 屬性在模型上訪問中間表中的屬性。 但是，你可以隨意自訂此屬性的名稱，以更好地反映其在應用程式中的用途。

例如，如果你的應用程式包含可能訂閱播客的使用者，則使用者和播客之間可能存在多對多關係。 如果是這種情況，你可能希望將中間表屬性重新命名為 `subscription` 而不是 `pivot`。 這可以在定義關係時使用 `as` 方法來完成：

    return $this->belongsToMany(Podcast::class)
                    ->as('subscription')
                    ->withTimestamps();

一旦定義完成，你可以使用自訂名稱訪問中間表資料：

    $users = User::with('podcasts')->get();

    foreach ($users->flatMap->podcasts as $podcast) {
        echo $podcast->subscription->created_at;
    }

### 通過中間表過濾查詢

你還可以在定義關係時使用 `wherePivot`、`wherePivotIn`、`wherePivotNotIn`、`wherePivotBetween`、`wherePivotNotBetween`、`wherePivotNull` 和 `wherePivotNotNull` 方法過濾 `belongsToMany` 關係查詢返回的結果：

    return $this->belongsToMany(Role::class)
                    ->wherePivot('approved', 1);

    return $this->belongsToMany(Role::class)
                    ->wherePivotIn('priority', [1, 2]);

    return $this->belongsToMany(Role::class)
                    ->wherePivotNotIn('priority', [1, 2]);

    return $this->belongsToMany(Podcast::class)
                    ->as('subscriptions')
                    ->wherePivotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);

    return $this->belongsToMany(Podcast::class)
                    ->as('subscriptions')
                    ->wherePivotNotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);

    return $this->belongsToMany(Podcast::class)
                    ->as('subscriptions')
                    ->wherePivotNull('expired_at');

    return $this->belongsToMany(Podcast::class)
                    ->as('subscriptions')
                    ->wherePivotNotNull('expired_at');



### 通過中間表欄位排序

你可以使用 `orderByPivot` 方法對 `belongsToMany` 關係查詢返回的結果進行排序。在下面的例子中，我們將檢索使用者的最新徽章：

    return $this->belongsToMany(Badge::class)
                    ->where('rank', 'gold')
                    ->orderByPivot('created_at', 'desc');

### 自訂中間表模型

如果你想定義一個自訂模型來表示多對多關係的中間表，你可以在定義關係時呼叫 `using` 方法。

自訂多對多中間表模型都必須繼承 `Illuminate\Database\Eloquent\Relations\Pivot` 類，自訂多對多（多型）中間表模型必須繼承 `Illuminate\Database\Eloquent\Relations\MorphPivot` 類。例如，我們在寫 `Role` 模型的關聯時，使用自訂中間表模型 `RoleUser`：

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\BelongsToMany;

    class Role extends Model
    {
        /**
         * 屬於該角色的使用者。
         */
        public function users(): BelongsToMany
        {
            return $this->belongsToMany(User::class)->using(RoleUser::class);
        }
    }

當定義 `RoleUser` 模型時，我們要繼承 `Illuminate\Database\Eloquent\Relations\Pivot` 類：

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Relations\Pivot;

    class RoleUser extends Pivot
    {
        // ...
    }

> **注意**
> Pivot 模型不可以使用 `SoftDeletes` trait。 如果需要軟刪除資料關聯記錄，請考慮將資料關聯模型轉換為實際的 Eloquent 模型。


#### 自訂中間模型和自增 ID

如果你用一個自訂的中繼模型定義了多對多的關係，而且這個中繼模型擁有一個自增的主鍵，你應當確保這個自訂中繼模型類中定義了一個 `incrementing` 屬性且其值為 `true`。

    /**
     * 標識 ID 是否自增
     *
     * @var bool
     */
    public $incrementing = true;

## 多型關係

多型關聯允許子模型使用單個關聯屬於多種類型的模型。例如，假設你正在建構一個應用程式，允許使用者共享部落格文章和視訊。在這樣的應用程式中，`Comment` 模型可能同時屬於 `Post` 和 `Video` 模型。

### 一對一 (多型)

#### 表結構

一對一多型關聯類似於典型的一對一關係，但是子模型可以使用單個關聯屬於多個類型的模型。例如，一個部落格 `Post` 和一個 `User` 可以共享到一個 `Image` 模型的多型關聯。使用一對一多型關聯允許你擁有一個唯一圖像的單個表，這些圖像可以與帖子和使用者關聯。首先，讓我們查看表結構：

    posts
        id - integer
        name - string

    users
        id - integer
        name - string

    images
        id - integer
        url - string
        imageable_id - integer
        imageable_type - string

請注意 `images` 表上的 `imageable_id` 和 `imageable_type` 兩列。`imageable_id` 列將包含帖子或使用者的ID值，而 `imageable_type` 列將包含父模型的類名。`imageable_type` 列用於 Eloquent 在訪問 `imageable` 關聯時確定要返回哪種類型的父模型。在本例中，該列將包含 `App\Models\Post` 或 `App\Models\User`。



#### 模型結構

接下來，讓我們來看一下建構這個關係所需的模型定義：

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\MorphTo;

    class Image extends Model
    {
        /**
         * 獲取父級 imageable 模型（使用者或帖子）。
         */
        public function imageable(): MorphTo
        {
            return $this->morphTo();
        }
    }

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\MorphOne;

    class Post extends Model
    {
        /**
         * 獲取文章圖片
         */
        public function image(): MorphOne
        {
            return $this->morphOne(Image::class, 'imageable');
        }
    }

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\MorphOne;

    class User extends Model
    {
        /**
         * 獲取使用者的圖片。
         */
        public function image(): MorphOne
        {
            return $this->morphOne(Image::class, 'imageable');
        }
    }

#### 檢索關聯關係

一旦定義了表和模型，就可以通過模型訪問此關聯。比如，要獲取文章圖片，可以使用 `image` 動態屬性：

    use App\Models\Post;

    $post = Post::find(1);

    $image = $post->image;

還可以通過訪問執行 `morphTo` 呼叫的方法名來從多型模型中獲知父模型。在這個例子中，就是 `Image` 模型的 `imageable` 方法。所以，我們可以像動態屬性那樣訪問這個方法：

    use App\Models\Image;

    $image = Image::find(1);

    $imageable = $image->imageable;

`Image` 模型上的 `imageable` 關係將返回 `Post` 實例或 `User` 實例，具體取決於模型擁有圖像的類型。

#### 鍵名約定

如有需要，你可以指定多型子模型中使用的 `id` 和 `type` 列的名稱。 如果這樣做，請確保始終將關聯名稱作為第一個參數傳遞給 `morphTo` 方法。 通常，此值應與方法名稱匹配，因此你可以使用 PHP 的 `__FUNCTION__` 常數：

    /**
     * 獲取 image 實例所屬的模型
     */
    public function imageable(): MorphTo
    {
        return $this->morphTo(__FUNCTION__, 'imageable_type', 'imageable_id');
    }



### 一對多（多型）

#### 表結構

一對多多型關聯與簡單的一對多關聯類似，不過，目標模型可以在一個關聯中從屬於多個模型。假設應用中的使用者可以同時「評論」文章和視訊。使用多型關聯，可以用單個 `comments` 表同時滿足這些情況。我們還是先來看看用來建構這種關聯的表結構：

    posts
        id - integer
        title - string
        body - text

    videos
        id - integer
        title - string
        url - string

    comments
        id - integer
        body - text
        commentable_id - integer
        commentable_type - string

#### 模型結構

接下來，看看建構這種關聯的模型定義：

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\MorphTo;

    class Comment extends Model
    {
        /**
         * 獲取擁有此評論的模型（Post 或 Video）。
         */
        public function commentable(): MorphTo
        {
            return $this->morphTo();
        }
    }

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\MorphMany;

    class Post extends Model
    {
        /**
         * 獲取此文章的所有評論
         */
        public function comments(): MorphMany
        {
            return $this->morphMany(Comment::class, 'commentable');
        }
    }

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\MorphMany;

    class Video extends Model
    {
        /**
         * 獲取此視訊的所有評論
         */
        public function comments(): MorphMany
        {
            return $this->morphMany(Comment::class, 'commentable');
        }
    }

#### 獲取關聯

一旦定義了資料庫表和模型，就可以通過模型訪問關聯。例如，可以使用 `comments` 動態屬性訪問文章的全部評論：

    use App\Models\Post;

    $post = Post::find(1);

    foreach ($post->comments as $comment) {
        // ...
    }



你還可以通過訪問執行對 `morphTo` 的呼叫的方法名來從多型模型獲取其所屬模型。在我們的例子中，這就是 `Comment` 模型上的 `commentable` 方法。因此，我們將以動態屬性的形式訪問該方法：

    use App\Models\Comment;

    $comment = Comment::find(1);

    $commentable = $comment->commentable;

`Comment` 模型的 `commentable` 關聯將返回 `Post` 或 `Video` 實例，其結果取決於評論所屬的模型。

### 一對多檢索（多型）

有時一個模型可能有許多相關模型，要檢索關係的「最新」或「最舊」相關模型。 例如，一個 `User` 模型可能與許多 `Image` 模型相關，如果你想自訂一種方便的方式來與使用者上傳的最新圖像進行互動。 可以使用 `morphOne` 關係類型結合 `ofMany` 方法來完成此操作：

```php
/**
 * 獲取使用者最近上傳的圖像。
 */
public function latestImage(): MorphOne
{
    return $this->morphOne(Image::class, 'imageable')->latestOfMany();
}
```

同樣，你也可以定義一個方法來檢索關係的「最早」或第一個相關模型：

```php
/**
 * 獲取使用者最早上傳的圖像。
 */
public function oldestImage(): MorphOne
{
    return $this->morphOne(Image::class, 'imageable')->oldestOfMany();
}
```

默認情況下，`latestOfMany` 和 `oldestOfMany` 方法將基於模型的主鍵（必須可排序）檢索最新或最舊的相關模型。但是，有時你可能希望使用不同的排序條件從較大的關係中檢索單個模型。


例如，使用 `ofMany` 方法，可以檢索使用者點贊最高的圖像。`ofMany` 方法接受可排序列作為其第一個參數，以及在查詢相關模型時應用哪個聚合函數（`min` 或 `max`）：

```php
/**
 * 獲取使用者最受歡迎的圖像。
 */
public function bestImage(): MorphOne
{
    return $this->morphOne(Image::class, 'imageable')->ofMany('likes', 'max');
}
```

> **提示**
> 要建構更高級的「一對多」關係。 請查看 [進階一對多檢索](#advanced-has-one-of-many-relationships).

### 多對多（多型）

#### 表結構

多對多多型關聯比 `morphOne` 和 `morphMany` 關聯略微複雜一些。例如，`Post` 和 `Video` 模型能夠共享關聯到 `Tag` 模型的多型關係。在這種情況下使用多對多多型關聯允許使用一個唯一標籤在部落格文章和視訊間共享。以下是多對多多型關聯的表結構：

    posts
        id - integer
        name - string

    videos
        id - integer
        name - string

    tags
        id - integer
        name - string

    taggables
        tag_id - integer
        taggable_id - integer
        taggable_type - string

> **提示**
> 在深入研究多型多對多關係之前，閱讀 [多對多關係](#many-to-many) 的文件會對你有幫助。


#### 模型結構

接下來，我們可以定義模型之間的關聯。`Post` 和 `Video` 模型都將包含一個 `tags` 方法，該方法呼叫了基礎 Eloquent 模型類提供的 `morphToMany` 方法。



`morphToMany` 方法接受相關模型的名稱以及“關係名稱”。根據我們分配給中間表的名稱及其包含的鍵，我們將將關係稱為 「taggable」：

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\MorphToMany;

    class Post extends Model
    {
        /**
         * 獲取帖子的所有標籤。
         */
        public function tags(): MorphToMany
        {
            return $this->morphToMany(Tag::class, 'taggable');
        }
    }

#### 定義多對多（多型）反向關係

接下來, 在這個 `Tag` 模型中, 你應該為每個可能的父模型定義一個方法. 所以, 在這個例子中, 我們將會定義一個  `posts` 方法 和 一個 `videos` 方法. 這兩個方法都應該返回 `morphedByMany`  結果。

`morphedByMany` 方法接受相關模型的名稱以及「關係名稱」。根據我們分配給中間表名的名稱及其包含的鍵，我們將該關係稱為「taggable」：

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\MorphToMany;

    class Tag extends Model
    {
        /**
         * 獲取分配給此標籤的所有帖子。
         */
        public function posts(): MorphToMany
        {
            return $this->morphedByMany(Post::class, 'taggable');
        }

        /**
         * 獲取分配給此視訊的所有帖子.
         */
        public function videos(): MorphToMany
        {
            return $this->morphedByMany(Video::class, 'taggable');
        }
    }

#### 獲取關聯

一旦定義了資料庫表和模型，你就可以通過模型訪問關係。 例如，要訪問帖子的所有標籤，你可以使用 `tags` 動態關係屬性：

    use App\Models\Post;

    $post = Post::find(1);

    foreach ($post->tags as $tag) {
        // ...
    }



還可以訪問執行 `morphedByMany` 方法呼叫的方法名來從多型模型獲取其所屬模型。在這個示例中，就是 `Tag` 模型的 `posts` 或 `videos` 方法。可以像動態屬性一樣訪問這些方法：

    use App\Models\Tag;

    $tag = Tag::find(1);

    foreach ($tag->posts as $post) {
        // ...
    }

    foreach ($tag->videos as $video) {
        // ...
    }

### 自訂多型類型

默認情況下，Laravel 將使用完全限定的類名來儲存相關模型的「類型」。 例如，給定上面的一對多關係示例，其中 `Comment` 模型可能屬於 `Post` 或 `Video`模型，默認的 `commentable_type` 將分別是 `App\Models\Post` 或 `App\Models\Video`。 但是，你可能希望將這些值與應用程式的內部結構解耦。

例如，我們可以使用簡單的字串，例如 `post` 和 `video`，而不是使用模型名稱作為「類型」。 通過這樣做，即使模型被重新命名，我們資料庫中的多型「類型」列值也將保持有效：

    use Illuminate\Database\Eloquent\Relations\Relation;

    Relation::enforceMorphMap([
        'post' => 'App\Models\Post',
        'video' => 'App\Models\Video',
    ]);

你可以在 `App\Providers\AppServiceProvider` 類的 `boot` 方法中呼叫 `enforceMorphMap` 方法，或者你也可以建立一個單獨的服務提供者。

你可以在執行階段使用 `getMorphClass` 方法確定給定模型的別名。相反，可以使用 `Relation::getMorphedModel` 方法來確定與別名相關聯的類名：

    use Illuminate\Database\Eloquent\Relations\Relation;

    $alias = $post->getMorphClass();

    $class = Relation::getMorphedModel($alias);

> **注意**
> 向現有應用程式新增「變形對應」時，資料庫中仍包含完全限定類的每個可變形 `*_type` 列值都需要轉換為其「對應」名稱。



### 動態關聯

你可以使用 `resolveRelationUsing` 方法在執行階段定義 Eloquent 模型之間的關係。雖然通常不建議在常規應用程式開發中使用它，但是在開發 Laravel 軟體包時，這有時可能會很有用。

`resolveRelationUsing` 方法的第一個參數是關聯名稱。傳遞給該方法的第二個參數應該是一個閉包，閉包接受模型實例並返回一個有效的 Eloquent 關聯定義。通常情況下，你應該在[服務提供器](https://learnku.com/docs/laravel/10.x/providersmd/14843)的啟動方法中組態動態關聯:

    use App\Models\Order;
    use App\Models\Customer;

    Order::resolveRelationUsing('customer', function (Order $orderModel) {
        return $orderModel->belongsTo(Customer::class, 'customer_id');
    });

> **注意**  
> 定義動態關係時，始終為 Eloquent 關係方法提供顯式的鍵名參數。

## 查詢關聯

因為所有的 Eloquent 關聯都是通過方法定義的，你可以呼叫這些方法來獲取關聯的實例，而無需真實執行查詢來獲取相關的模型。此外，所有的 Eloquent 關聯也可以用作[查詢構造器](https://learnku.com/docs/laravel/10.x/queriesmd/14883)，允許你在最終對資料庫執行 SQL 查詢之前，繼續通過鏈式呼叫新增約束條件。

例如，假設有一個部落格系統，它的 `User` 模型有許多關聯的 `Post` 模型:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\HasMany;

    class User extends Model
    {
        /**
         * 獲取該使用者的所有文章.
         */
        public function posts(): HasMany
        {
            return $this->hasMany(Post::class);
        }
    }

你可以查詢 `posts` 關聯，並給它新增額外的約束條件，如下例所示:

    use App\Models\User;

    $user = User::find(1);

    $user->posts()->where('active', 1)->get();



你可以在關聯上使用任意的 [查詢構造器]([查詢構造器 | 《Laravel 10 中文文件》 (learnku.com)](https://learnku.com/docs/laravel/10.x/queriesmd/14883)) 方法，所以一定要閱讀查詢構造器的文件，瞭解它的所有方法，這會對你非常有用。

#### 在關聯之後鏈式新增 `orWhere` 子句

如上例所示，你可以在查詢關聯時，自由的給關聯新增額外的約束條件。但是，在將 `orWhere` 子句連結到關聯上時，一定要小心，因為 `orWhere` 子句將在邏輯上與關聯約束處於同一等級：

    $user->posts()
            ->where('active', 1)
            ->orWhere('votes', '>=', 100)
            ->get();

上面的例子將生成以下 SQL。像你看到的那樣， 這個 `or` 子句的查詢指令，將返回大於 100 票的任一使用者，查詢不再限於特定的使用者：

```sql
select *
from posts
where user_id = ? and active = 1 or votes >= 100
```

在大多數情況下，你應該使用 [邏輯分組]([查詢構造器 | 《Laravel 10 中文文件》 (learnku.com)](https://learnku.com/docs/laravel/10.x/queriesmd/14883#logical-grouping)) 在括號中對條件檢查進行分組：

    use Illuminate\Database\Eloquent\Builder;

    $user->posts()
            ->where(function (Builder $query) {
                return $query->where('active', 1)
                             ->orWhere('votes', '>=', 100);
            })
            ->get();

上面的示例將生成以下 SQL。 請注意，邏輯分組已正確分組約束，並且查詢仍然受限於特定使用者：

```sql
select *
from posts
where user_id = ? and (active = 1 or votes >= 100)
```

### 關聯方法 VS 動態屬性

如果你不需要向 Eloquent 關聯查詢新增額外的約束，你可以像訪問屬性一樣訪問關聯。 例如，繼續使用我們的 `User` 和 `Post` 示例模型，我們可以像這樣訪問使用者的所有帖子：

    use App\Models\User;

    $user = User::find(1);

    foreach ($user->posts as $post) {
        // ...
    }



動態屬性是 「懶載入」 的，只有實際訪問到才會載入關聯資料。因此，通常用 [預載入](#eager-loading) 來準備模型需要用到的關聯資料。預載入能大量減少因載入模型關聯執行的 SQL 語句。 

### 基於存在的關聯查詢

在檢索模型記錄時，你可能希望基於關係的存在限制結果。例如，假設你想檢索至少有一條評論的所有部落格文章。為了實現這一點，你可以將關係名稱傳遞給 `has` 和 `orHas` 方法：

    use App\Models\Post;

    // 檢索所有至少有一條評論的文章...
    $posts = Post::has('comments')->get();

也可以指定運算子和數量來進一步自訂查詢：

    // 檢索所有有三條或更多評論的文章...
    $posts = Post::has('comments', '>=', 3)->get();

可以使用用「.」語法構造巢狀的 `has` 語句。例如，你可以檢索包含至少一張圖片的評論的所有文章：

    // 查出至少有一條帶圖片的評論的文章...
    $posts = Post::has('comments.images')->get();

如果你需要更多的功能，你可以使用 `whereHas` 和 `orWhereHas` 方法在 `has` 查詢中定義額外的查詢約束，例如檢查評論的內容：

    use Illuminate\Database\Eloquent\Builder;

    // 檢索至少有一條評論包含類似於 code% 單詞的文章...
    $posts = Post::whereHas('comments', function (Builder $query) {
        $query->where('content', 'like', 'code%');
    })->get();

    // 檢索至少有十條評論包含類似於 code% 單詞的文章...
    $posts = Post::whereHas('comments', function (Builder $query) {
        $query->where('content', 'like', 'code%');
    }, '>=', 10)->get();

> **注意**
> Eloquent 目前不支援跨資料庫查詢關係是否存在。 這些關係必須存在於同一資料庫中。



#### 內聯關係存在查詢

如果你想使用附加到關係查詢簡單的 where 條件來確認關係是否存在，使用 `whereRelation`, `orWhereRelation`, `whereMorphRelation`和 `orWhereMorphRelation` 方法更方便. 例如，查詢所有評論未獲批准的帖子:

    use App\Models\Post;

    $posts = Post::whereRelation('comments', 'is_approved', false)->get();

當然，就像呼叫查詢建構器的 `where` 方法一樣，你也可以指定一個運算子：

    $posts = Post::whereRelation(
        'comments', 'created_at', '>=', now()->subHour()
    )->get();

### 查詢不存在的關聯

檢索模型記錄時，你可能會根據不存在關係來限制結果。例如，要檢索所有**沒有**任何評論的所有部落格文章。 可以將關係的名稱傳遞給 `doesntHave` 和 `orDoesntHave` 方法：

    use App\Models\Post;

    $posts = Post::doesntHave('comments')->get();

如果需要更多功能，可以使用 `whereDoesntHave` 和 `orWhereDoesntHave` 方法將「where」 條件加到 `doesntHave` 查詢上。這些方法允許你向關聯加入自訂限制，比如檢測評論內容：

    use Illuminate\Database\Eloquent\Builder;

    $posts = Post::whereDoesntHave('comments', function (Builder $query) {
        $query->where('content', 'like', 'code%');
    })->get();

你可以使用「點」符號對巢狀關係執行查詢。例如，以下查詢將檢索所有沒有評論的帖子；但是，有未被禁止的作者評論的帖子將包含在結果中:

    use Illuminate\Database\Eloquent\Builder;

    $posts = Post::whereDoesntHave('comments.author', function (Builder $query) {
        $query->where('banned', 0);
    })->get();



### 查詢多型關聯

要查詢「多型關聯」的存在，可以使用 `whereHasMorph` 和 `whereDoesntHaveMorph` 方法。這些方法接受關聯名稱作為它們的第一個參數。接下來，這些方法接受你希望在查詢中包含的相關模型的名稱。最後，你可以提供一個閉包來自訂關聯查詢。

    use App\Models\Comment;
    use App\Models\Post;
    use App\Models\Video;
    use Illuminate\Database\Eloquent\Builder;

    // 檢索與標題類似於 code% 的帖子或視訊相關的評論。
    $comments = Comment::whereHasMorph(
        'commentable',
        [Post::class, Video::class],
        function (Builder $query) {
            $query->where('title', 'like', 'code%');
        }
    )->get();

    // 檢索與標題不類似於 code% 的帖子相關的評論。
    $comments = Comment::whereDoesntHaveMorph(
        'commentable',
        Post::class,
        function (Builder $query) {
            $query->where('title', 'like', 'code%');
        }
    )->get();

你可能需要根據相關多型模型的「類型」新增查詢約束。傳遞給 `whereHasMorph` 方法的閉包可以接收 `$type` 值作為其第二個參數。此參數允許你檢查正在建構的查詢的「類型」：

    use Illuminate\Database\Eloquent\Builder;

    $comments = Comment::whereHasMorph(
        'commentable',
        [Post::class, Video::class],
        function (Builder $query, string $type) {
            $column = $type === Post::class ? 'content' : 'title';

            $query->where($column, 'like', 'code%');
        }
    )->get();

#### 查詢所有相關模型

你可以使用萬用字元 `*` 代替多型模型的陣列，這將告訴 Laravel 從資料庫中檢索所有可能的多型類型。為了執行此操作，Laravel 將執行額外的查詢：

    use Illuminate\Database\Eloquent\Builder;

    $comments = Comment::whereHasMorph('commentable', '*', function (Builder $query) {
        $query->where('title', 'like', 'foo%');
    })->get();



## 聚合相關模型

### 計算相關模型的數量

有時候你可能想要計算給定關係的相關模型的數量，而不實際載入模型。為了實現這一點，你可以使用 `withCount` 方法。`withCount` 方法將在生成的模型中放置一個 `{relation}_count` 屬性：

    use App\Models\Post;

    $posts = Post::withCount('comments')->get();

    foreach ($posts as $post) {
        echo $post->comments_count;
    }

通過將陣列傳遞給 withCount 方法，你可以同時新增多個關係的 "計數"，並向查詢新增其他約束：

    use Illuminate\Database\Eloquent\Builder;

    $posts = Post::withCount(['votes', 'comments' => function (Builder $query) {
        $query->where('content', 'like', 'code%');
    }])->get();

    echo $posts[0]->votes_count;
    echo $posts[0]->comments_count;

你還可以給關係計數結果起別名，從而在同一關係上進行多個計數：

    use Illuminate\Database\Eloquent\Builder;

    $posts = Post::withCount([
        'comments',
        'comments as pending_comments_count' => function (Builder $query) {
            $query->where('approved', false);
        },
    ])->get();

    echo $posts[0]->comments_count;
    echo $posts[0]->pending_comments_count;

#### 延遲計數載入

使用 `loadCount` 方法，你可以在獲取父模型後載入關係計數：

    $book = Book::first();

    $book->loadCount('genres');

如果你需要在計數查詢上設定其他查詢約束，你可以傳遞一個以你想要計數的關係為鍵的陣列。陣列的值應該是接收查詢建構器實例的閉包：

    $book->loadCount(['reviews' => function (Builder $query) {
        $query->where('rating', 5);
    }])



#### 關聯計數和自訂查詢欄位

如果你的查詢同時包含 `withCount` 和 `select`，請確保 `withCount` 一定在 `select` 之後呼叫：

    $posts = Post::select(['title', 'body'])
                    ->withCount('comments')
                    ->get();

### 其他聚合函數

除了 `withCount` 方法外，Eloquent 還提供了 `withMin`, `withMax`, `withAvg` 和 `withSum` 等聚合方法。
這些方法會通過 `{relation}_{function}_{column}` 的命名方式將聚合結果新增到獲取到的模型屬性中：

    use App\Models\Post;

    $posts = Post::withSum('comments', 'votes')->get();

    foreach ($posts as $post) {
        echo $post->comments_sum_votes;
    }

如果你想使用其他名稱訪問聚合函數的結果，可以自訂的別名：

    $posts = Post::withSum('comments as total_comments', 'votes')->get();

    foreach ($posts as $post) {
        echo $post->total_comments;
    }

與 `loadCount` 方法類似，這些方法也有延遲呼叫的方法。這些延遲方法可在已獲取到的 Eloquent 模型上呼叫：


    $post = Post::first();

    $post->loadSum('comments', 'votes');

如果你將這些聚合方法和一個 `select` 語句組合在一起，確保你在 `select` 方法之後呼叫聚合方法:

    $posts = Post::select(['title', 'body'])
                    ->withExists('comments')
                    ->get();

### 多型關聯計數

如果你想預載入多型關聯關係以及這個關聯關係關聯的其他關聯關係的計數統計，可以通過將 `with` 方法與 `morphTo` 關係和 `morphWithCount` 方法結合來實現。

在這個例子中，我們假設 `Photo` 和 `Post` 模型可以建立 `ActivityFeed` 模型。 我們將假設 `ActivityFeed`模型定義了一個名為`parentable`的多型關聯關係，它允許我們為給定的 `ActivityFeed` 實例檢索父級 `Photo` 或 `Post` 模型。 此外，讓我們假設 `Photo` 模型有很多 `Tag` 模型、`Post` 模型有很多 `Comment` 模型。



假如我們想要檢索 `ActivityFeed` 實例並為每個 `ActivityFeed` 實例預先載入 `parentable` 父模型。 此外，我們想要檢索與每張父照片關聯的標籤數量以及與每個父帖子關聯的評論數量：

    use Illuminate\Database\Eloquent\Relations\MorphTo;

    $activities = ActivityFeed::with([
        'parentable' => function (MorphTo $morphTo) {
            $morphTo->morphWithCount([
                Photo::class => ['tags'],
                Post::class => ['comments'],
            ]);
        }])->get();

#### 延遲計數載入

假設我們已經檢索了一組 `ActivityFeed` 模型，現在我們想要載入與活動提要關聯的各種 `parentable` 模型的巢狀關係計數。 可以使用 `loadMorphCount` 方法來完成此操作：

    $activities = ActivityFeed::with('parentable')->get();

    $activities->loadMorphCount('parentable', [
        Photo::class => ['tags'],
        Post::class => ['comments'],
    ]);

## 預載入

當將 Eloquent 關係作為屬性訪問時，相關模型是延遲載入的。 這意味著在你第一次訪問該屬性之前不會實際載入關聯資料。 但是，Eloquent 可以在查詢父模型時主動載入關聯關係。 預載入減輕了 `N + 1` 查詢問題。 為了說明 `N + 1` 查詢問題，請參考屬於 `Author` 模型的 `Book` 模型：

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\BelongsTo;

    class Book extends Model
    {
        /**
         * 獲取寫了這本書的作者。
         */
        public function author(): BelongsTo
        {
            return $this->belongsTo(Author::class);
        }
    }

現在，讓我們檢索所有書籍及其作者：

    use App\Models\Book;

    $books = Book::all();

    foreach ($books as $book) {
        echo $book->author->name;
    }



該循環將執行一個查詢以檢索資料庫表中的所有書籍，然後對每本書執行另一個查詢以檢索該書的作者。 因此，如果我們有 25 本書，上面的程式碼將運行 26 個查詢：一個查詢原本的書籍資訊，另外 25 個查詢來檢索每本書的作者。

值得慶幸的是，我們可以使用預載入將這個操作減少到兩個查詢。 在建構查詢時，可以使用 `with` 方法指定應該預載入哪些關係： 

    $books = Book::with('author')->get();

    foreach ($books as $book) {
        echo $book->author->name;
    }

對於此操作，將只執行兩個查詢 - 一個查詢檢索書籍，一個查詢檢索所有書籍的作者：

```sql
select * from books

select * from authors where id in (1, 2, 3, 4, 5, ...)
```

#### 預載入多個關聯

有時，你可能需要在單一操作中預載入幾個不同的關聯。要達成此目的，只要向 `with` 方法傳遞多個關聯名稱構成的陣列參數：

    $books = Book::with(['author', 'publisher'])->get();

#### 巢狀預載入

可以使用 「.」 語法預載入巢狀關聯。比如在一個 Eloquent 語句中預載入所有書籍作者及其聯絡方式：

    $books = Book::with('author.contacts')->get();

另外，你可以通過向 `with` 方法提供巢狀陣列來指定巢狀的預載入關係，這在預載入多個巢狀關係時非常方便。

    $books = Book::with([
        'author' => [
            'contacts',
            'publisher',
        ],
    ])->get();



#### 巢狀預載入 `morphTo` 關聯

如果你希望載入一個 `morphTo` 關係，以及該關係可能返回的各種實體的巢狀關係，可以將 `with` 方法與 `morphTo` 關係的 `morphWith` 方法結合使用。為了說明這種方法，讓我們參考以下模型：

    <?php

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\MorphTo;

    class ActivityFeed extends Model
    {
        /**
         * 獲取活動記錄的父記錄。
         */
        public function parentable(): MorphTo
        {
            return $this->morphTo();
        }
    }

在這個例子中，我們假設 `Event`，`Photo` 和 `Post` 模型可以建立 `ActivityFeed` 模型。 另外，我們假設 `Event` 模型屬於 `Calendar` 模型，`Photo` 模型與 `Tag` 模型相關聯，`Post` 模型屬於 `Author` 模型。

使用這些模型定義和關聯，我們可以查詢 `ActivityFeed` 模型實例並預載入所有 `parentable` 模型及其各自的巢狀關係：

    use Illuminate\Database\Eloquent\Relations\MorphTo;

    $activities = ActivityFeed::query()
        ->with(['parentable' => function (MorphTo $morphTo) {
            $morphTo->morphWith([
                Event::class => ['calendar'],
                Photo::class => ['tags'],
                Post::class => ['author'],
            ]);
        }])->get();

#### 預載入指定列

並不是總需要獲取關係的每一列。在這種情況下，Eloquent 允許你為關聯指定想要獲取的列:

    $books = Book::with('author:id,name,book_id')->get();

> **注意**
> 使用此功能時，應始終在要檢索的列列表中包括 `id` 列和任何相關的外部索引鍵列。



#### 默認預載入

有時可能希望在查詢模型時始終載入某些關聯。 為此，你可以在模型上定義 `$with` 屬性

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\BelongsTo;

    class Book extends Model
    {
        /**
         * 默認預載入的關聯。
         *
         * @var array
         */
        protected $with = ['author'];

        /**
         * 獲取書籍作者。
         */
        public function author(): BelongsTo
        {
            return $this->belongsTo(Author::class);
        }

        /**
         * 獲取書籍類型。
         */
        public function genre(): BelongsTo
        {
            return $this->belongsTo(Genre::class);
        }
    }

如果你想從單個查詢的 `$with` 屬性中刪除一個預載入，你可以使用 `without` 方法：

    $books = Book::without('author')->get();

如果你想要覆蓋 `$with` 屬性中所有項，僅針對單個查詢，你可以使用 `withOnly` 方法：

    $books = Book::withOnly('genre')->get();

### 約束預載入

有時，你可能希望預載入一個關聯，同時為預載入查詢新增額外查詢條件。你可以通過將一個關聯陣列傳遞給 `with` 方法來實現這一點，其中陣列鍵是關聯名稱，陣列值是一個閉包，它為預先載入查詢新增了額外的約束：

    use App\Models\User;

    $users = User::with(['posts' => function (Builder $query) {
        $query->where('title', 'like', '%code%');
    }])->get();

在這個例子中，Eloquent 只會預載入帖子的 `title` 列包含單詞 `code` 的帖子。 你可以呼叫其他 [查詢構造器](/docs/laravel/10.x/queries) 方法來自訂預載入操作：

    $users = User::with(['posts' => function (Builder $query) {
        $query->orderBy('created_at', 'desc');
    }])->get();

> **注意**
> 在約束預載入時，不能使用 limit 和 take 查詢構造器方法。



#### `morphTo` 關聯預載入新增約束

如果你在使用 Eloquent 進行 `morphTo` 關聯的預載入時，Eloquent 將運行多個查詢以獲取每種類型的相關模型。你可以使用 `MorphTo` 關聯的 `constrain` 方法向每個查詢新增附加約束條件：

    use Illuminate\Database\Eloquent\Builder;
    use Illuminate\Database\Eloquent\Relations\MorphTo;

    $comments = Comment::with(['commentable' => function (MorphTo $morphTo) {
        $morphTo->constrain([
            Post::class => function (Builder $query) {
                $query->whereNull('hidden_at');
            },
            Video::class => function (Builder $query) {
                $query->where('type', 'educational');
            },
        ]);
    }])->get();

在這個例子中，Eloquent 只會預先載入未被隱藏的帖子，並且視訊的 `type` 值為 `educational`。

#### 基於存在限制預載入

有時候，你可能需要同時檢查關係的存在性並根據相同條件載入關係。例如，你可能希望僅查詢具有符合給定條件的子模型 `Post` 的 `User` 模型，同時也預載入匹配的文章。你可以使用 Laravel 中的 `withWhereHas` 方法來實現這一點。

    use App\Models\User;
    use Illuminate\Database\Eloquent\Builder;

    $users = User::withWhereHas('posts', function (Builder $query) {
        $query->where('featured', true);
    })->get();

### 延遲預載入

有時你可能需要在查詢父模型之後預載入關聯。例如，如果你需要動態地決定是否載入相關模型，則這可能非常有用：

    use App\Models\Book;

    $books = Book::all();

    if ($someCondition) {
        $books->load('author', 'publisher');
    }



如果要在渴求式載入的查詢語句中進行條件約束，可以通過陣列的形式去載入，鍵為對應的關聯關係，值為 `Closure` 閉包涵數，該閉包的參數為一個查詢實例：

    $author->load(['books' => function (Builder $query) {
        $query->orderBy('published_date', 'asc');
    }]);

如果希望僅載入未被載入的關聯關係時，你可以使用 `loadMissing` 方法：

    $book->loadMissing('author');

#### 巢狀延遲預載入 & `morphTo`

如果要預載入 `morphTo` 關係，以及該關係可能返回的各種實體上的巢狀關係，你可以使用 `loadMorph` 方法。

這個方法接受 `morphTo` 關係的名稱作為它的第一個參數，第二個參數接收模型陣列、關係陣列。例如:

    <?php

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\MorphTo;

    class ActivityFeed extends Model
    {
        /**
         * 獲取活動提要記錄的父項。
         */
        public function parentable(): MorphTo
        {
            return $this->morphTo();
        }
    }

在這個例子中，讓我們假設 `Event` 、`Photo` 和 `Post` 模型可以建立 `ActivityFeed` 模型。此外，讓我們假設 `Event` 模型屬於 `Calendar` 模型，`Photo` 模型與 `Tag` 模型相關聯，`Post` 模型屬於 `Author` 模型。

使用這些模型定義和關聯關係，我們方可以檢索 `ActivityFeed` 模型實例，並立即載入所有 `parentable` 模型及其各自的巢狀關係：

    $activities = ActivityFeed::with('parentable')
        ->get()
        ->loadMorph('parentable', [
            Event::class => ['calendar'],
            Photo::class => ['tags'],
            Post::class => ['author'],
        ]);



### 防止延遲載入

如前所述，預載入關係可以為應用程式提供顯著的性能優勢。 但你也可以指示 Laravel 始終防止延遲載入關係。 你可以呼叫基本 Eloquent 模型類提供的 `preventLazyLoading` 方法。 通常，你應該在應用程式的 `AppServiceProvider` 類的 `boot` 方法中呼叫此方法。

`preventLazyLoading` 方法接受一個可選的布林值類型的參數，表示是否阻止延遲載入。例如，你可能希望只在非生產環境中停用延遲載入，這樣即使在生產環境程式碼中意外出現了延遲載入關係，你的生產環境也能繼續正常運行。

```php
use Illuminate\Database\Eloquent\Model;

/**
 * 引導應用程式服務。
 */
public function boot(): void
{
    Model::preventLazyLoading(! $this->app->isProduction());
}
```

在阻止延遲載入之後，當你的應用程式嘗試延遲載入任何 Eloquent 關係時，Eloquent 將拋出 `Illuminate\Database\LazyLoadingViolationException` 異常。

你可以使用 `handleLazyLoadingViolationsUsing` 方法自訂延遲載入的違規行為。例如，使用此方法，你可以指示違規行為只被記錄，而不是使用異常中斷應用程式的執行：

```php
Model::handleLazyLoadingViolationUsing(function (Model $model, string $relation) {
    $class = get_class($model);

    info("Attempted to lazy load [{$relation}] on model [{$class}].");
});
```

## 插入 & 更新關聯模型

### `save` 方法

Eloquent 提供了向關係中新增新模型的便捷方法。例如，你可能需要向一篇文章（`Post` 模型）新增一條新的評論（`Comment` 模型），你不用手動設定 `Comment` 模型上的 `post_id` 屬性，你可以直接使用關聯模型中的 `save` 方法：

    use App\Models\Comment;
    use App\Models\Post;

    $comment = new Comment(['message' => 'A new comment.']);

    $post = Post::find(1);

    $post->comments()->save($comment);



注意，我們沒有將 `comments` 關聯作為動態屬性訪問，相反，我們呼叫了 `comments` 方法來來獲得關聯實例， `save` 方法會自動新增適當的 `post_id` 值到新的 `Comment` 模型中。

如果需要保存多個關聯模型，你可以使用 `saveMany` 方法：

    $post = Post::find(1);

    $post->comments()->saveMany([
        new Comment(['message' => 'A new comment.']),
        new Comment(['message' => 'Another new comment.']),
    ]);

`save` 和 `saveMany` 方法不會將新模型（`Comment`）載入到父模型（`Post`) 上， 如果你計畫在使用 `save` 或 `saveMany` 方法後訪問該關聯模型（`Comment`），你需要使用 `refresh` 方法重新載入模型及其關聯，這樣你就可以訪問到所有評論，包括新保存的評論了：

    $post->comments()->save($comment);

    $post->refresh();

    // 所有評論，包括新保存的評論...
    $post->comments;

#### 遞迴保存模型和關聯資料

如果你想 `save` 模型及其所有關聯資料，你可以使用 `push` 方法，在此示例中，將保存 `Post` 模型及其評論和評論作者：

    $post = Post::find(1);

    $post->comments[0]->message = 'Message';
    $post->comments[0]->author->name = 'Author Name';

    $post->push();

`pushQuietly` 方法可用於保存模型及其關聯關係，而不觸發任何事件：

    $post->pushQuietly();

###  `create` 方法

除了 `save` 和 `saveMany` 方法外，你還可以使用 `create` 方法。它接受一個屬性陣列，同時會建立模型並插入到資料庫中。 還有， `save` 和 `create` 方法的不同之處在於， `save` 方法接受一個完整的 Eloquent 模型實例，而 `create` 則接受普通的 PHP 陣列：

    use App\Models\Post;

    $post = Post::find(1);

    $comment = $post->comments()->create([
        'message' => 'A new comment.',
    ]);



你還可以使用 `createMany` 方法去建立多個關聯模型：

    $post = Post::find(1);

    $post->comments()->createMany([
        ['message' => 'A new comment.'],
        ['message' => 'Another new comment.'],
    ]);

還可以使用 `createQuietly` 和 `createManyQuietly`方法建立模型，而無需調度任何事件：

    $user = User::find(1);

    $user->posts()->createQuietly([
        'title' => 'Post title.',
    ]);
	
    $user->posts()->createManyQuietly([
        ['title' => 'First post.'],
        ['title' => 'Second post.'],
    ]);

你還可以使用 `findOrNew`, `firstOrNew`, `firstOrCreate` 和 `updateOrCreate` 方法來 [建立和更新關係模型](/docs/laravel/10.x/eloquent#upserts)。

> **注意**：在使用 `create` 方法前，請務必確保查看過本文件的 [批次賦值](/docs/laravel/10.x/eloquent#mass-assignment) 章節。

### Belongs To 關聯

如果你想將子模型分配給新的父模型，你可以使用 `associate` 方法。在這個例子中，`User` 模型定義了一個與 `Account` 模型的 `belongsTo` 關係。 這個 `associate` 方法將在子模型上設定外部索引鍵：

    use App\Models\Account;

    $account = Account::find(10);

    $user->account()->associate($account);

    $user->save();

要從子模型中刪除父模型，你可以使用 `dissociate` 方法。此方法會將關聯外部索引鍵設定為 `null`：

    $user->account()->dissociate();

    $user->save();

### 多對多關聯

#### 附加 / 分離

Eloquent 也提供了一些額外的輔助方法，使相關模型的使用更加方便。例如，我們假設一個使用者可以擁有多個角色，並且每個角色都可以被多個使用者共享。給某個使用者附加一個角色是通過向中間表插入一條記錄實現的，可以使用 `attach` 方法完成該操作：

    use App\Models\User;

    $user = User::find(1);

    $user->roles()->attach($roleId);



在將關係附加到模型時，還可以傳遞一組要插入到中間表中的附加資料：

    $user->roles()->attach($roleId, ['expires' => $expires]);

當然，有時也需要移除使用者的角色。可以使用 `detach` 移除多對多關聯記錄。`detach` 方法將會移除中間表對應的記錄。但是這兩個模型都將會保留在資料庫中:

    // 移除使用者的一個角色...
    $user->roles()->detach($roleId);

    // 移除使用者的所有角色...
    $user->roles()->detach();

為了方便起見，`attach` 和 `detach` 也允許傳遞一個 IDs 陣列：

    $user = User::find(1);

    $user->roles()->detach([1, 2, 3]);

    $user->roles()->attach([
        1 => ['expires' => $expires],
        2 => ['expires' => $expires],
    ]);

#### 同步關聯

你也可以使用 `sync` 方法建構多對多關聯。`sync` 方法接收一個 IDs 陣列以替換中間表的記錄。中間表記錄中，所有未在 IDs 陣列中的記錄都將會被移除。所以該操作結束後，只有給出陣列的 IDs 會被保留在中間表中：

    $user->roles()->sync([1, 2, 3]);

你也可以通過 IDs 傳遞額外的附加資料到中間表：

    $user->roles()->sync([1 => ['expires' => true], 2, 3]);

如果你想為每個同步的模型 IDs 插入相同的中間表，你可以使用 `syncWithPivotValues` 方法：

    $user->roles()->syncWithPivotValues([1, 2, 3], ['active' => true]);

如果你不想移除現有的 IDs，可以使用 `syncWithoutDetaching` 方法：

    $user->roles()->syncWithoutDetaching([1, 2, 3]);



#### 切換關聯

多對多關聯也提供了 `toggle` 方法用於「切換」給定 ID 陣列的附加狀態。 如果給定的 ID 已被附加在中間表中，那麼它將會被移除，同樣，如果給定的 ID 已被移除，它將會被附加：

    $user->roles()->toggle([1, 2, 3]);

你還可以將附加的中間表值與ID 一起傳遞：

    $user->roles()->toggle([
        1 => ['expires' => true],
        2 => ['expires' => true],
    ]);

#### 更新中間表上的記錄

如果你需要在中間表中更新一條已存在的記錄，可以使用 `updateExistingPivot` 方法。 此方法接收中間表的外部索引鍵與要更新的資料陣列進行更新：

    $user = User::find(1);

    $user->roles()->updateExistingPivot($roleId, [
        'active' => false,
    ]);

## 更新父級時間戳

當一個模型屬 `belongsTo` 或者 `belongsToMany` 另一個模型時， 例如 `Comment` 屬於 `Post` ，有時更新子模型導致更新父模型時間戳非常有用。

例如，當 `Comment` 模型被更新時，你需要自動「觸發」父級 `Post` 模型的 `updated_at` 時間戳的更新。`Eloquent` 讓它變得簡單。只要在子模型加一個包含關聯名稱的 `touches` 屬性即可：:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;
    use Illuminate\Database\Eloquent\Relations\BelongsTo;

    class Comment extends Model
    {
        /**
         * 需要觸發的所有關聯關係。
         *
         * @var array
         */
        protected $touches = ['post'];

        /**
         * 獲取評論所屬文章。
         */
        public function post(): BelongsTo
        {
            return $this->belongsTo(Post::class);
        }
    }

> **注意**：只有使用 `Eloquent` 的 `save` 方法更新子模型時，才會觸發更新父模型時間戳。

